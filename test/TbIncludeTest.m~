classdef TbIncludeTest  < matlab.unittest.TestCase
    % Test transitive toolbox resolution.
    %
    % The Toolbox Toolbox should be able to nest configurations using the
    % "include" record type.  It should be able to avoid "include" loops.
    % It should be able to include toolboxes from a registry of JSON files.
    %
    % 2016 benjamin.heasly@gmail.com
    
    properties
        tempFolder = fullfile(tempdir(), 'TbIncludeTest');
        originalMatlabPath;
    end
    
    methods (TestMethodSetup)
        function clearTempFolder(obj)
            if 7 == exist(obj.tempFolder, 'dir')
                rmdir(obj.tempFolder, 's');
            end
            mkdir(obj.tempFolder);
        end
        
        function saveOriginalMatlabState(obj)
            obj.originalMatlabPath = path();
            tbResetMatlabPath('withSelf', true, 'withInstalled', true);
        end
    end
    
    methods (TestMethodTeardown)
        function restoreOriginalMatlabState(obj)
            path(obj.originalMatlabPath);
        end
    end
    
    methods (Test)
        function testNoInclude(obj)
            % trivial case with nothing to include
            originalConfig = [ ...
                tbToolboxRecord('name', 'simple-1', 'type', 'git'), ...
                tbToolboxRecord('name', 'simple-2', 'type', 'git'), ...
                tbToolboxRecord('name', 'simple-3', 'type', 'git'), ...
                ];
            
            resolvedConfig = TbIncludeStrategy.resolveIncludedConfigs(originalConfig);
            obj.assertEqual(resolvedConfig, originalConfig);
        end
        
        function testNoDuplicates(obj)
            % include one config from another, exclude duplicates by name
            includedConfig = [ ...
                tbToolboxRecord('name', 'included-1', 'type', 'git'), ...
                tbToolboxRecord('name', 'included-2', 'type', 'git'), ...
                tbToolboxRecord('name', 'included-3', 'type', 'git'), ...
                tbToolboxRecord('name', 'duplicate', 'type', 'git'), ...
                ];
            includedConfigPath = fullfile(obj.tempFolder, 'includeMe.json');
            tbWriteConfig(includedConfig, 'configPath', includedConfigPath);
            
            originalConfig = [ ...
                tbToolboxRecord('name', 'original-1', 'type', 'git'), ...
                tbToolboxRecord('name', 'original-2', 'type', 'git'), ...
                tbToolboxRecord('name', 'duplicate', 'type', 'git'), ...
                tbToolboxRecord( ...
                'name', 'includeIt', ...
                'type', 'include', ...
                'url', includedConfigPath), ...
                ];
            
            resolvedConfig = TbIncludeStrategy.resolveIncludedConfigs(originalConfig);
            resolvedNames = {resolvedConfig.name};
            expectedNames = {'original-1', 'original-2', 'duplicate', 'included-1', 'included-2', 'included-3'};
            obj.assertEqual(resolvedNames, expectedNames);
        end
        
        function testIndirectInclude(obj)
            % include a config indirectly through an intermediate
            baseConfig = [ ...
                tbToolboxRecord('name', 'base-1', 'type', 'git'), ...
                tbToolboxRecord('name', 'base-2', 'type', 'git'), ...
                tbToolboxRecord('name', 'base-3', 'type', 'git'), ...
                ];
            baseConfigPath = fullfile(obj.tempFolder, 'base.json');
            tbWriteConfig(baseConfig, 'configPath', baseConfigPath);
            
            middleConfig = tbToolboxRecord( ...
                'name', 'base-ref', ...
                'type', 'include', ...
                'url', baseConfigPath);
            middleConfigPath = fullfile(obj.tempFolder, 'middle.json');
            tbWriteConfig(middleConfig, 'configPath', middleConfigPath);
            
            originalConfig = [ ...
                tbToolboxRecord('name', 'original-1', 'type', 'git'), ...
                tbToolboxRecord('name', 'original-2', 'type', 'git'), ...
                tbToolboxRecord( ...
                'name', 'middle-ref', ...
                'type', 'include', ...
                'url', middleConfigPath), ...
                ];
            
            resolvedConfig = TbIncludeStrategy.resolveIncludedConfigs(originalConfig);
            resolvedNames = {resolvedConfig.name};
            expectedNames = {'original-1', 'original-2', 'base-1', 'base-2', 'base-3'};
            obj.assertEqual(resolvedNames, expectedNames);
            
        end
        
        function testReflexiveInclude(obj)
            % let a config include itself harmlessly
            selfConfigPath = fullfile(obj.tempFolder, 'self.json');
            selfConfig = [ ...
                tbToolboxRecord('name', 'self-1', 'type', 'git'), ...
                tbToolboxRecord('name', 'self-2', 'type', 'git'), ...
                tbToolboxRecord('name', 'self-3', 'type', 'git'), ...
                tbToolboxRecord( ...
                'name', 'self-ref', ...
                'type', 'include', ...
                'url', selfConfigPath)
                ];
            tbWriteConfig(selfConfig, 'configPath', selfConfigPath);
            
            resolvedConfig = TbIncludeStrategy.resolveIncludedConfigs(selfConfig);
            resolvedNames = {resolvedConfig.name};
            expectedNames = {'self-1', 'self-2', 'self-3'};
            obj.assertEqual(resolvedNames, expectedNames);
        end
        
        function testSymmetricInclude(obj)
            % let two configs include each other harmlessly
            redConfigPath = fullfile(obj.tempFolder, 'red.json');
            blueConfigPath = fullfile(obj.tempFolder, 'blue.json');
            redConfig = [ ...
                tbToolboxRecord('name', 'red-1', 'type', 'git'), ...
                tbToolboxRecord('name', 'red-2', 'type', 'git'), ...
                tbToolboxRecord('name', 'red-3', 'type', 'git'), ...
                tbToolboxRecord( ...
                'name', 'blue-ref', ...
                'type', 'include', ...
                'url', blueConfigPath)
                ];
            tbWriteConfig(redConfig, 'configPath', redConfigPath);
            
            blueConfig = [ ...
                tbToolboxRecord('name', 'blue-1', 'type', 'git'), ...
                tbToolboxRecord('name', 'blue-2', 'type', 'git'), ...
                tbToolboxRecord('name', 'blue-3', 'type', 'git'), ...
                tbToolboxRecord( ...
                'name', 'red-ref', ...
                'type', 'include', ...
                'url', redConfigPath)
                ];
            tbWriteConfig(blueConfig, 'configPath', blueConfigPath);
            
            resolvedConfig = TbIncludeStrategy.resolveIncludedConfigs(redConfig);
            resolvedNames = {resolvedConfig.name};
            expectedNames = {'red-1', 'red-2', 'red-3', 'blue-1', 'blue-2', 'blue-3'};
            obj.assertEqual(resolvedNames, expectedNames);
        end
        
        function testRegistryInclude(obj)
    end
end
